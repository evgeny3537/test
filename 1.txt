[AppDomain]::CurrentDomain.GetAssemblies() | ForEach-Object { $_.GetName().Name }



Add-Type -AssemblyName WindowsBase
Add-Type -AssemblyName PresentationCore
Add-Type -AssemblyName PresentationFramework
Add-Type -AssemblyName System.Xaml
Add-Type -AssemblyName System.Windows.Forms

convert input.png -morphology Close Disk:5 -trim +repage output.png


convert input.png -define connected-components:area-threshold=5 -connected-components 8 -trim +repage output_trimmed.PNG



  
$hex = & magick.exe "magic.exe" -resize "1x1!" -format "%[hex:p{0,0}]" info:
Write-Host "Average HEX color: #$hex"



| Where-Object { $_.Name -notmatch '^склеенные' }



# Пути к файлам (измените при необходимости)
$imagePath = "input.jpg"
$outputPath = "output.jpg"

# Получение размеров изображения с помощью ImageMagick (используйте 'magick identify' или 'identify', в зависимости от установки)
$dimensions = & magick identify -format "%w %h" $imagePath
$sizeParts = $dimensions.Trim().Split(" ")
$width  = [int]$sizeParts[0]
$height = [int]$sizeParts[1]

# Вычисление координат стартовых точек для floodfill:
# Для левой полосы: x = 1, y = height/2
# Для правой полосы: x = (width - 2), y = height/2
$leftX  = 1
$leftY  = [math]::Round($height/2)
$rightX = $width - 2
$rightY = $leftY

# Формирование строк координат
$leftPoint  = "$leftX,$leftY"
$rightPoint = "$rightX,$rightY"

# Вывод вычисленных параметров для отладки (по желанию)
Write-Host "Размер изображения: $width x $height"
Write-Host "Левая точка floodfill: $leftPoint"
Write-Host "Правая точка floodfill: $rightPoint"

# Выполнение команды замены цвета на белый с использованием floodfill.
# Параметр -fuzz 10% можно настраивать в зависимости от вариативности цвета боковой полосы.
& magick convert $imagePath -fuzz 10% -draw "color $leftPoint floodfill" -draw "color $rightPoint floodfill" $outputPath

Write-Host "Обработка завершена. Результат сохранён в $outputPath"





# Получаем список всех доступных модулей (имена)
$allModules = Get-Module -ListAvailable | Select-Object -ExpandProperty Name -Unique

# Импортируем каждый модуль
foreach ($mod in $allModules) {
    try {
        Import-Module $mod -ErrorAction Stop
        Write-Host "Загружен модуль: $mod"
    } catch {
        Write-Warning "Не удалось загрузить модуль: $mod"
    }
}



# Пример попытки загрузить несколько типичных .NET сборок
$assemblies = @(
    "System", "System.Core", "System.Data", "System.Drawing",
    "System.IO.Compression", "System.Management", "System.Net.Http",
    "System.Security", "System.Windows.Forms", "System.Xml", "System.Xml.Linq"
)

foreach ($asm in $assemblies) {
    try {
        [System.Reflection.Assembly]::Load($asm) | Out-Null
        Write-Host "Загружена сборка: $asm"
    } catch {
        Write-Warning "Не удалось загрузить сборку: $asm"
    }
}



