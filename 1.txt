# Load Windows Forms assembly
Add-Type -AssemblyName System.Windows.Forms

# Create the form
$form = New-Object System.Windows.Forms.Form
$form.Text = 'Время проверки'
$form.Width = 300
$form.Height = 150

# Add a label to display status
$label = New-Object System.Windows.Forms.Label
$label.AutoSize = $true
$label.Location = '20,20'
$label.Font = 'Microsoft Sans Serif,12'
$label.Text = 'Ожидание события...'
$form.Controls.Add($label)

# Add key event handler for hiding the form with Alt+H
$form.KeyPreview = $true
$form.Add_KeyDown({
    if ($_.Alt -and $_.KeyCode -eq 'H') {
        $label.Text = 'Сочетание Alt+H — скрываем форму.'
        $form.Hide()
    }
})

# Display the form initially (hidden)
$form.Hide()

$windowShown = $false

# Define start and end time window
$startTime = [datetime]::Today.AddHours(14).AddMinutes(0)     # 14:00
$endTime = [datetime]::Today.AddHours(1).AddMinutes(9).AddDays(1)  # 01:09 next day

while ($true) {
    $now = Get-Date

    if ($now -ge $startTime -and $now -lt $endTime) {
        if (-not $windowShown) {
            $label.Text = "Сейчас $($now.ToString('HH:mm')) — показываем форму."
            $form.Show()
            $windowShown = $true
        }
    }
    else {
        if ($form.Visible) {
            $label.Text = "Сейчас $($now.ToString('HH:mm')) — скрываем форму."
            $form.Hide()
            $windowShown = $false
        }
    }

    Start-Sleep -Seconds 5
    [System.Windows.Forms.Application]::DoEvents()
}














# Путь к исходному файлу и куда сохранить результат
$imagePath = "input.jpg"
$outputPath = "output.jpg"

# Получение размеров изображения (ширина и высота) с помощью ImageMagick
$dimensions = & magick identify -format "%w %h" $imagePath
$sizeParts = $dimensions.Trim().Split(" ")
$width  = [int]$sizeParts[0]
$height = [int]$sizeParts[1]

# Вычисление координат:
$centerX = [math]::Round($width/2)
$centerY = [math]::Round($height/2)
$leftX  = 1
$leftY  = [math]::Round($height/2)
$rightX = $width - 2
$rightY = $leftY

Write-Host "Размер изображения: $width x $height"
Write-Host "Центр: $centerX,$centerY"
Write-Host "Левая точка: $leftX,$leftY"
Write-Host "Правая точка: $rightX,$rightY"

# Функция для получения цвета пикселя по координатам.
function Get-PixelColor($imgPath, $x, $y) {
    # Возвращаем строку "R,G,B" (значения 0-255).
    $colorString = & magick convert $imgPath -format "%[fx:int(255*r)],%[fx:int(255*g)],%[fx:int(255*b)]" "pixel:p{$x,$y}" info:
    return $colorString.Trim()
}

# Получение цвета центрального пикселя, левого и правого пикселей.
$centerColor = Get-PixelColor $imagePath $centerX $centerY
$leftColor   = Get-PixelColor $imagePath $leftX $leftY
$rightColor  = Get-PixelColor $imagePath $rightX $rightY

Write-Host "Цвет центра: $centerColor"
Write-Host "Цвет левого края: $leftColor"
Write-Host "Цвет правого края: $rightColor"

# Функция для парсинга строки "R,G,B" в объект с компонентами.
function Parse-Color($colorString) {
    $parts = $colorString.Split(",")
    return @{ r = [int]$parts[0]; g = [int]$parts[1]; b = [int]$parts[2] }
}

$centerRGB = Parse-Color $centerColor
$leftRGB   = Parse-Color $leftColor
$rightRGB  = Parse-Color $rightColor

# Функция для вычисления евклидовой разницы между двумя цветами.
function ColorDifference($col1, $col2) {
    $dr = $col1.r - $col2.r
    $dg = $col1.g - $col2.g
    $db = $col1.b - $col2.b
    return [math]::Sqrt($dr*$dr + $dg*$dg + $db*$db)
}

$diffLeft  = ColorDifference $centerRGB $leftRGB
$diffRight = ColorDifference $centerRGB $rightRGB

Write-Host "Разница между центром и левым краем: $diffLeft"
Write-Host "Разница между центром и правым краем: $diffRight"

# Пороговое значение разницы (настроить при необходимости)
$threshold = 20  # Например, если разность ниже 20 (из 255), считаем, что цвет почти одинаков

if (($diffLeft -lt $threshold) -and ($diffRight -lt $threshold)) {
    Write-Host "Цвета центра и боковых областей почти идентичны. Обработка не выполняется."
    # Например, можно просто скопировать исходное изображение:
    Copy-Item $imagePath $outputPath
    Write-Host "Исходное изображение скопировано в $outputPath"
} else {
    Write-Host "Цветовые различия достаточно велики, выполняется обработка."
    # Выполнение floodfill: замена боковых областей на белый без изменения размеров.
    & magick convert $imagePath -fuzz 10% -fill white -draw "color $leftX,$leftY floodfill" -fill white -draw "color $rightX,$rightY floodfill" $outputPath
    Write-Host "Обработка выполнена, результат сохранён в $outputPath"
}




[AppDomain]::CurrentDomain.GetAssemblies() | ForEach-Object { $_.GetName().Name }



Add-Type -AssemblyName WindowsBase
Add-Type -AssemblyName PresentationCore
Add-Type -AssemblyName PresentationFramework
Add-Type -AssemblyName System.Xaml
Add-Type -AssemblyName System.Windows.Forms

convert input.png -morphology Close Disk:5 -trim +repage output.png


convert input.png -define connected-components:area-threshold=5 -connected-components 8 -trim +repage output_trimmed.PNG



  
$hex = & magick.exe "magic.exe" -resize "1x1!" -format "%[hex:p{0,0}]" info:
Write-Host "Average HEX color: #$hex"



| Where-Object { $_.Name -notmatch '^склеенные' }



# Пути к файлам (измените при необходимости)
$imagePath = "input.jpg"
$outputPath = "output.jpg"

# Получение размеров изображения с помощью ImageMagick (используйте 'magick identify' или 'identify', в зависимости от установки)
$dimensions = & magick identify -format "%w %h" $imagePath
$sizeParts = $dimensions.Trim().Split(" ")
$width  = [int]$sizeParts[0]
$height = [int]$sizeParts[1]

# Вычисление координат стартовых точек для floodfill:
# Для левой полосы: x = 1, y = height/2
# Для правой полосы: x = (width - 2), y = height/2
$leftX  = 1
$leftY  = [math]::Round($height/2)
$rightX = $width - 2
$rightY = $leftY

# Формирование строк координат
$leftPoint  = "$leftX,$leftY"
$rightPoint = "$rightX,$rightY"

# Вывод вычисленных параметров для отладки (по желанию)
Write-Host "Размер изображения: $width x $height"
Write-Host "Левая точка floodfill: $leftPoint"
Write-Host "Правая точка floodfill: $rightPoint"

# Выполнение команды замены цвета на белый с использованием floodfill.
# Параметр -fuzz 10% можно настраивать в зависимости от вариативности цвета боковой полосы.
& magick convert $imagePath -fuzz 10% -draw "color $leftPoint floodfill" -draw "color $rightPoint floodfill" $outputPath

Write-Host "Обработка завершена. Результат сохранён в $outputPath"





# Получаем список всех доступных модулей (имена)
$allModules = Get-Module -ListAvailable | Select-Object -ExpandProperty Name -Unique

# Импортируем каждый модуль
foreach ($mod in $allModules) {
    try {
        Import-Module $mod -ErrorAction Stop
        Write-Host "Загружен модуль: $mod"
    } catch {
        Write-Warning "Не удалось загрузить модуль: $mod"
    }
}



# Пример попытки загрузить несколько типичных .NET сборок
$assemblies = @(
    "System", "System.Core", "System.Data", "System.Drawing",
    "System.IO.Compression", "System.Management", "System.Net.Http",
    "System.Security", "System.Windows.Forms", "System.Xml", "System.Xml.Linq"
)

foreach ($asm in $assemblies) {
    try {
        [System.Reflection.Assembly]::Load($asm) | Out-Null
        Write-Host "Загружена сборка: $asm"
    } catch {
        Write-Warning "Не удалось загрузить сборку: $asm"
    }
}



